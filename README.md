Импорт категорий каталога
===============================

Laravel 5.5, MySQL/MariaDB 5.5


## Проектные изменения:

0. Структура
   * добавлена папка vhost с конфигом хоста для nginx под Windows. Можно сделать include в главный nginx.conf, предварительно поправив пути и секцию "location ~ \.php$";
   * добавлена папка import с json файлом каталога, используется по-умолчанию.
 

1. Конфиги
   * установлен пакет "davejamesmiller/laravel-breadcrumbs" (composer.json) для отображения "хлебных крошек" на страницах каталога;
   * установлен laravel-mix для сборки стилей (скрипты не нужны, настройка в webpack.mix.js);
   * дефолты для конфигурации приложения и подключения к базе в config/app.php;
   * добавлены "диски" import и "project" в Storage (config/filesystems.php).


2. Консольная команда app/Console/Commands/ImportCatalog
Сигнатура вызова: import:catalog {file?}
Зарегистрирована в свойстве commands класса app/Console/Kernel.
Если путь и имя файла не указаны, то используется дефолтный import/catalog.js


3. ORM и database
   * добавлены модели app/Category (категория каталога) и app/CategoryOldUrl (старая ссылка на категорию);
   * добавлен obverver app/Observers/CategoryObserver для описания хэндлеров событий сохранения. Подключение в app/Providers/AppServiceProvider (метод boot);
   * добавлены файлы миграций, создающих таблицы (database/migrations);


4. Фронтенд
   * добавлен контроллер app/Http/Controllers/CatalogController;
   * настроены маршруты и соответствующие им "хлебные крошки" в routes/web.php: '/' - главная страница с деревом каталога, 'catalog/{url}' - страница категории;
   * добавлены виды для базовой страницы, страниц каталога и категорий, вспомогательный вид для генерации дерева (resources/views);
   * добавлен файл кастомных стилей (resources/assets/sass/catalog.scss) и переопределены некоторые переменные в _variables.scss.


## Как работает:
Команда принимает на вход необязательный параметр - путь к файлу со структурой каталога. Ищет его на "диске" "project" (base_path проекта). Если параметр не указан, то берётся файл по-умолчанию (import/catalog.json). Команда по указанному id ищет уже созданную категорию или создаёт новую, заполняет указанными атрибутами.
При изменении названия категории генерируется новый url. При этом создаётся запись в "истории" url для возможности делать редиректы на актуальные адреса. Так же генерируются новые url для дочерних категорий, поскольку они включают в себя родительский url. Если категория сохраняется без id, то id генерируется как максимум + 1 на соответствующем уровне вложенности. При сохранении модели с заданным id проверяется буквенный префикс для правильного соотношения в иерархии.
Необходимость редиректа определяется следующим образом:
* ищется категория, url которой соответствует запросу. Если она найдена, то редирект не требуется;
* ищется категория, которая последней имела старое значение url равное искомому. Последняя потому что до того, как стать старой ссылкой категории X, она была актуальной, т.е. имела приоритет по сравнению с такой же старой для категории Y. Т.о. мы уже тогда не получали редирект на Y. Поэтому, если в старых ссылках окажется одинаковое значение для X и Y, будет выбрана та категория, которая обновила url позже. Если найдена, то 301 редирект на актуальный адрес категории.
* если в обоих случаях категория не определена, то отображается страница 404.
Есть вероятность получить некорректное перенаправление из-за кэширования 301 редиректов браузером (см. пример в комментарии к app/Http/controllers/CatalogController@category).


## Что не получилось:
* не работает валидация unique для полей id и url категории при попытке исключить текущую запись из проверки (ignore).


## Что можно доделать:
* детальные сообщения об ошибках валидации;
* сообщения на английском языке либо поддержка кириллицы в выводе консоли и логах;
* триггер-проверка уникальности для url в категории на уровне базы. Теоретически поле может содержать строку длиной больше 255 символов. Учитывая, что url ещё и включает родительский, тип данных varchar(255) может не вместить всю строку. Поэтому был выбран тип text. Но он исключает возможность наложить уникальный индекс на поле. На уровне приложения за уникальностью призван следить валидатор (который работает некорректно). Не лишним подстраховаться и сделать проверку на уровне MySQL - кастомный триггер, который в случае нарушения уникальности при изменении значения его - изменение - запретит.